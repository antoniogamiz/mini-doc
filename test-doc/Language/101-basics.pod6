=begin pod :tag<tutorial>

=TITLE  Perl 6 by example P6-101

=SUBTITLE A basic introductory example of a Perl 6 program

Suppose that you host a table tennis tournament.  The referees tell you
the results of each game in the format C<Player1 Player2 | 3:2>, which
means that C<Player1> won against C<Player2> by 3 to 2 sets. You need a
script that sums up how many matches and sets each player has won to
determine the overall winner.

The input data (stored in a file called C<scores.txt>) looks like this:

=for code :lang<data>
Beth Ana Charlie Dave
Ana Dave | 3:0
Charlie Beth | 3:1
Ana Beth | 2:3
Dave Charlie | 3:0
Ana Charlie | 3:1
Beth Dave | 0:3

The first line is the list of players.  Every subsequent line records a result
of a match.

Here's one way to solve that problem in Perl 6:

=begin code :solo
use v6;

my $file  = open 'scores.txt';
my @names = $file.get.words;

my %matches;
my %sets;

for $file.lines -> $line {
    next unless $line; # ignore any empty lines

    my ($pairing, $result) = $line.split(' | ');
    my ($p1, $p2)          = $pairing.words;
    my ($r1, $r2)          = $result.split(':');

    %sets{$p1} += $r1;
    %sets{$p2} += $r2;

    if $r1 > $r2 {
        %matches{$p1}++;
    } else {
        %matches{$p2}++;
    }
}

my @sorted = @names.sort({ %sets{$_} }).sort({ %matches{$_} }).reverse;

for @sorted -> $n {
    say "$n has won %matches{$n} matches and %sets{$n} sets";
}
=end code

This produces the output:

=for code :lang<text>
Ana has won 2 matches and 8 sets
Dave has won 2 matches and 6 sets
Charlie has won 1 matches and 4 sets
Beth has won 1 matches and 4 sets

=head3 X<C<v6>|v6 (Basics)>

Every Perl 6 program should begin with a line similar to C<use v6;>. This line
tells the compiler which version of Perl the program expects. Should you
accidentally run the file with Perl 5, you'll get a helpful error message.  6.c
is an example of a Perl 6 version.

=head3 X<C<statement>|statement (Basics)>

A Perl 6 program consists of zero or more statements. A I<statement> ends with
a semicolon or a curly brace at the end of a line:

=begin code
my $file = open 'scores.txt';
=end code

=head3 X<C<lexical>> and X<C<block>>

C<my> declares a lexical variable, which are visible only in the current block
from the point of declaration to the end of the block. If there's no enclosing
block, it's visible throughout the remainder of the file (which would
effectively be the enclosing block). A block is any part of the code enclosed
between curly braces C<{ }>.

=head3 X<C<sigil>> and X<C<identifier>|identifier (Basics)>

A variable name begins with a I<sigil>, which is a non-alpha-numeric
symbol such as C<$>, C<@>, C<%>, or C<&>--or occasionally the double
colon C<::>. Sigils indicate the structural interface for the variable,
such as whether it should be treated as a single value, a compound value,
a subroutine, etc. After the sigil comes an I<identifier>, which may
consist of letters, digits and the underscore. Between letters you can
also use a dash C<-> or an apostrophe C<'>, so C<isn't> and
C<double-click> are valid identifiers.

=head3 X<C<scalar>>

Sigils indicate the default access method for a variable. Variables
with the C<@> sigil are accessed positionally; variables with the C<%>
sigil are accessed by string key. The C<$> sigil, however, indicates a
general scalar container that can hold any single value and be accessed
in any manner. A scalar can even contain a compound object like an
C<Array> or a C<Hash>; the C<$> sigil signifies that it should be
treated as a single value, even in a context that expects multiple
values (as with an C<Array> or C<Hash>).

=head3 X<C<filehandle>> and X<C<assignment>>

The built-in function C<open> opens a file, here named C<scores>, and returns a
I<filehandle>--an object representing that file. The equality sign C<=>
I<assigns> that filehandle to the variable on the left, which means that
C<$file> now stores the filehandle.

=head3 X<C<string literal>>

C<'scores.txt'> is a I<string literal>. A string is a piece of text, and a
string literal is a string which appears directly in the program. In this line,
it's the argument provided to C<open>.

=begin code :preamble<my $file>
my @names = $file.get.words;
=end code

=head3 X<C<array>>, X<C<method>|method (Basics)> and X<C<invocant>|invocant (Basics)>

The right-hand side calls a I<method> --a named group of behavior-- named C<get>
on the filehandle stored in C<$file>.  The C<get> method reads and returns
one line from the file, removing the line ending.  If you print the contents of C<$file>
after calling C<get>, you will see that the first line is no longer in there. C<words> is also a method,
called on the string returned from C<get>. C<words> decomposes its
I<invocant>--the string on which it operates--into a list of words, which
here means strings separated by whitespace.
It turns the single string C<'Beth Ana Charlie Dave'> into the list of
strings C<'Beth', 'Ana', 'Charlie', 'Dave'>.

Finally, this list gets stored in the L<Any|/type/Any> C<@names>.  The C<@> sigil marks
the declared variable as an C<Array>.  Arrays store ordered lists.

=begin code
my %matches;
my %sets;
=end code

=head3 X<C<hash>>

These two lines of code declare two hashes.  The C<%> sigil marks each variable
as a C<Hash>.  A C<Hash> is an unordered collection of key-value pairs.  Other
programming languages call that a I<hash table>, I<dictionary>, or I<map>.  You
can query a hash table for the value that corresponds to a certain C<$key> with
C<%hash{$key}>.

In the score counting program, C<%matches> stores the number of matches each
player has won.  C<%sets> stores the number of sets each player has won. Both
of these hashes are indexed by the player's name.

=begin code :preamble<my $file>
for $file.lines -> $line {
    ...
}
=end code

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
