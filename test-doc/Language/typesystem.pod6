=begin pod :tag<perl6>

=TITLE Type system

=SUBTITLE Introduction to the type system of Perl 6

=head1 Definition of a Perl 6 type

A type defines a new object by creating a type object that provides an
interface to create instances of objects or to check values against. Any type
object is a subclass of L<Any|/type/Any> or L<Mu|/type/Mu>. Introspection
methods are provided via inheritance from those base classes and the
introspection postfix L<.^|/language/operators#postfix_.^>. A new type is
introduced to the current scope by one of the following type declarators at
compile time or with the L<meta object protocol|/language/mop> at runtime. All
type names must be unique in their scope.

=head2 Default types

If no type is provided by the user Perl 6 assumes the type to be C<Any>. This
includes L<containers|/language/containers>, base-classes,
L<parameters|/type/Signature#Type_constraints> and return types.

    my $a = 1;
    $a = Nil;
    say $a.^name;
    # OUTPUT: «Any␤»

    class C {};
    say C.^parents(:all);
    # OUTPUT: «((Any) (Mu))␤»

For containers the default type is C<Any> but the default type constraint is
C<Mu>. Please note that binding replaces the container, not just the value. The
type constraint may change in this case.

=head2 Type objects

To test if an object is a type object, use
L<smartmatch|/language/operators#index-entry-smartmatch_operator>
against a type constrained with a
L<type smiley|/type/Signature#Constraining_defined_and_undefined_values> or
L«C<.DEFINITE>|/language/mop#index-entry-syntax_DEFINITE-DEFINITE» method:

=begin code :ok-test<WHAT>
my $a = Int;
say $a ~~ Mu:U;
# OUTPUT: «True␤»
say not $a.DEFINITE;
# OUTPUT: «True␤»
=end code

C<.DEFINITE> will return C<True> if the invocant is an instance. If it returns
C<False>, then the invocant is a type object.

=head3 Undefinedness

Undefined objects maintain type information in Perl 6. Type objects are used to
represent both undefinedness and the type of the undefined value. To provide a
general undefined value use L<Any|/type/Any>. If differentiation from C<Any>,
the default type for containers and arguments, is required use L<Mu|/type/Mu>.

Instances of objects created by L<.CREATE|/type/Mu#method_CREATE> are by
convention defined. The method L<.defined|/type/Mu#routine_defined> will return
C<Bool::True> to indicate definedness. The exceptions to that rule are
L<Nil|/type/Nil> and L<Failure|/type/Failure>. Please note that any object is
able to overload C<.defined> and as such can carry additional information.
Also, Perl 6 makes a clear distinction between definedness and trueness. Many
values are defined even though they carry the meaning of wrongness or
emptiness. Such values are C<0>, L<Bool::False|/type/Bool>,
L<()|/language/operators#term_(_)> (empty list) and L<NaN|/type/Num#NaN>.

Values can become undefined at runtime via L<mixin|/language/operators#infix_but>.

    my Int $i = 1 but role :: { method defined { False } };
    say $i // "undefined";
    # OUTPUT: «undefined␤»

To test for definedness call C<.defined>, use
L<//|/language/operators#infix_//>,
 L<with/without|/language/control#with,_orwith,_without> and
L<signatures|/type/Signature#Constraining_defined_and_undefined_values>.

=head3 Coercion

Turning one type into another is done with coercion methods that have the same
name as the target type. This convention is made mandatory by
L<Signatures|/type/Signature#Coercion_type>. The source type has to know how to
turn itself into the target type. To allow built-in types to turn themselves
into user defined types use
L<augment|/language/variables#The_augment_declarator> or the
L<MOP|/language/mop>.

    class C {
        has $.int;
        method this-is-c { put 'oi' x $!int ~ '‽' }
    }

    use MONKEY-TYPING;
    augment class Int {
        method C { C.new(:int(self))}
    }

    my $i = 10;
    $i.=C;
    $i.this-is-c();
    # OUTPUT: «oioioioioioioioioioi‽␤»

Perl 6 provides methods defined in L<Cool|/type/Cool> to convert to a target
type before applying further operations. Most built-in types descend from
C<Cool> and as such may provide implicit coercion that may be undesired. It is
the responsibility of the user to care about trap-free usage of those
methods.

    my $whatever = "123.6";
    say $whatever.round;
    # OUTPUT: «124␤»
    say <a b c d>.starts-with("ab");
    # OUTPUT: «False␤»

=head1 Type declarators

Type declarators introduce a new type into the given scope. Nested scopes can
be separated by C<::>. New L<packages|/language/packages> are created
automatically if no such scope exists already.

    class Foo::Bar::C {};
    put Foo::Bar::.keys;
    # OUTPUT: «C␤»

X«|... (forward declaration)»
X«Forward declarations» can be provided with a block containing only C<...>. The
compiler will check at the end of the current scope if the type is defined.

    class C {...}
    # many lines later
    class C { has $.attr }

=head2 C<class>

The C<class> declarator creates a compile time construct that is compiled into a
type object. The latter is a simple Perl 6 object and provides methods to
construct instances by executing initializers and sub methods to fill all
attributes declared in a class, and any parent class, with values. Initializers
can be provided with the declaration of attributes or in constructors. It's the
responsibility of the L<Metamodel::ClassHOW|/type/Metamodel::ClassHOW> to know
how to run them. This is the only magic part of building objects in Perl 6. The
default parent type is C<Any>, which in turn inherits from C<Mu>. The latter
provides the default constructor C<.new> which is named like this by convention.
Aside from this, C<.new> does not carry any special meaning nor is treated in
any special way.

For more information how to use classes see the L<Classes and objects|/language/classtut>
tutorial.

=head3 Mixins

The type introduced by C<class> can be extended with
L«infix:<but>|/language/operators#infix_but» at runtime. The original type is
not modified, instead a new type object is returned and can be stored in
a container that type checks successful against the original type or the role
that is mixed in.

    class A {}
    role R { method m { say 'oi‽' } }
    my R $A = A but R;
    my $a1 = $A.new;
    $a1.m;
    say [$A ~~ R, $a1 ~~ R];
    # OUTPUT: «oi‽␤[True True]␤»

=head3 Introspection

=head4 Metaclass

To test if a given type object is a class, test the meta object method C<.HOW>
against L<Metamodel::ClassHOW|/type/Metamodel::ClassHOW>.

    class C {};
    say C.HOW ~~ Metamodel::ClassHOW;
    # OUTPUT: «True␤»

=head3 Private attributes

Private L<attribute|/type/Attribute>s are addressed with any of the twigils
C<$!>, C<@!> and C<%!>. They do not have public accessor methods generated
automatically.  As such they can not be altered from outside the class they are
defined in.

    class C {
        has $!priv;
        submethod BUILD { $!priv = 42 }
    };

    say (.name, .package, .has_accessor) for C.new.^attributes;
    # OUTPUT: «($!priv (C) False)␤»

X«|method (declarator)»
=head3 Methods

The C<method> declarator defines objects of type L<Method|/type/Method> and
binds them to the provided name in the scope of a class. Methods in a class are
C<has> scoped by default. Methods that are C<our> scoped are not added to the
method cache by default and as such can not be called with the accessor sigil
C<$.>. Call them with their fully qualified name and the invocant as the
first argument.

=head4 Inheritance and multis

A normal method in a subclass does not compete with multis of a parent class.

    class A {
        multi method m(Int $i){ say 'Int' }
        multi method m(int $i){ say 'int' }
    }

    class B is A {
        method m(Int $i){ say 'B::Int' }
    }

    my int $i;
    B.new.m($i);
    # OUTPUT: «B::Int␤»

X«|only method»
=head4 Only method

To explicitly state that a method is not a multi method use the C<only> method
declarator.

=for code :skip-test<compile time error>
class C {
    only method m {};
    multi method m {};
};
# OUTPUT: «X::Comp::AdHoc: Cannot have a multi candidate for 'm' when an only method is also in the package 'C'␤»

=head4 Submethod BUILD

The L<submethod|/type/Submethod> C<BUILD> is (indirectly) called by
L<.bless|/type/Mu#method_bless>. It
is meant to set private and public attributes of a class and receives all names
attributes passed into C<.bless>. The default
constructor L<.new|/type/Mu#method_new> defined in C<Mu> is the method that
invokes it. Given that public accessor methods are not available in C<BUILD>,
you must use private attribute notation instead.

    class C {
        has $.attr;
        submethod BUILD (:$attr = 42) {
            $!attr = $attr
        };
        multi method new($positional) {
            self.bless(:attr($positional), |%_)
       }
    };

    C.new.say; C.new('answer').say;
    # OUTPUT: «C.new(attr => 42)␤
    #          C.new(attr => "answer")␤»

=head4 Fallback method
X<|FALLBACK (method)>

A method with the special name C<FALLBACK> will be called when other means to
resolve the name produce no result. The first argument holds the name and all
following arguments are forwarded from the original call. Multi methods and
L«sub-signatures|/type/Signature#Destructuring_arguments» are supported.

    class Magic {
        method FALLBACK ($name, |c(Int, Str)) {
        put "$name called with parameters {c.perl}"  }
    };
    Magic.new.simsalabim(42, "answer");

    # OUTPUT: «simsalabim called with parameters ⌈\(42, "answer")⌋␤»

X<|WHAT (reserved method)>X<|WHO (reserved method)>
X<|HOW (reserved method)>X<|VAR (reserved method)>
=head4 Reserved method names

Some built-in introspection methods are actually special syntax provided by the
compiler, namely C<WHAT>, C<WHO>, C<HOW> and C<VAR>. Declaring methods with
those names will silently fail. A dynamic call will work, what allows to call
methods from foreign objects.

=begin code :ok-test<WHAT>
class A {
    method WHAT { "ain't gonna happen" }
};

say A.new.WHAT;    # OUTPUT: «(A)␤»
say A.new."WHAT"() # OUTPUT: «ain't gonna happen␤»
=end code

=head4 Methods in package scope

Any C<our> scoped method will be visible in the package scope of a class.

    class C {
        our method packaged {};
        method loose {}
    };
    say C::.keys
    # OUTPUT: «(&packaged)␤»

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
