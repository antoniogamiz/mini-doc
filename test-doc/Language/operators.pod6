=begin pod :tag<perl6>

=TITLE Operators

=SUBTITLE Common Perl 6 infixes, prefixes, postfixes, and more!

See L<creating operators|/language/optut> on how to define new operators.

=head1 Operator precedence

In an expression like C<1 + 2 * 3>, the C<2 * 3> is evaluated first
because the infix C<*> has tighter B<precedence> than the C<+>.

The following table summarizes the precedence levels in Perl 6, from
tightest to loosest:

=begin table

    A | Level            |   Examples
    ==+==================+==========
    N | Terms            |   42 3.14 "eek" qq["foo"] $x :!verbose @$array rand time now ∅
    L | Method postfix   |   .meth .\+ .? .* .() .[] .{} .<> .«» .:: .= .^ .:
    N | Autoincrement    |   \+\+ --
    R | Exponentiation   |   **
    L | Symbolic unary   |   ! \+ - ~ ? \| \|\| \+^ ~^ ?^ ^
    L | Dotty infix      |   .= .
    L | Multiplicative   |   * × / ÷ % %% \+& \+< \+> ~& ~< ~> ?& div mod gcd lcm
    L | Additive         |   \+ - − \+\| \+^ ~\| ~^ ?\| ?^
    L | Replication      |   x xx
    X | Concatenation    |   ~ o ∘
    X | Junctive and     |   & (&) (.) ∩ ⊍
    X | Junctive or      |   \| ^ (\|) (^) (\+) (-) ∪ ⊖ ⊎ ∖
    L | Named unary      |   temp let
    N | Structural infix |   but does <=> leg unicmp cmp coll .. ..^ ^.. ^..^
    C | Chaining infix   |   != ≠ == < <= ≤ > >= ≥ eq ne lt le gt ge ~~ === eqv !eqv =~= ≅ (elem) (cont) (<) (>) (<=) (>=) (<\+) (>\+) ∈ ∉ ∋ ∌ ⊂ ⊄ ⊃ ⊅ ⊆ ⊈ ⊇ ⊉ ≼ ≽
    X | Tight and        |   &&
    X | Tight or         |   \|\| ^^ // min max
    R | Conditional      |   ?? !! ff ff^ ^ff ^ff^ fff fff^ ^fff ^fff^
    R | Item assignment  |   = => \+= -= **= xx=
    L | Loose unary      |   so not
    X | Comma operator   |   , :
    X | List infix       |   Z minmax X X~ X* Xeqv ... … ...^ …^
    R | List prefix      |   print push say die map substr ... [\+] [*] any Z=
    X | Loose and        |   and andthen notandthen
    X | Loose or         |   or xor orelse
    X | Sequencer        |   <==, ==>, <<==, ==>>
    N | Terminator       |   ; {...}, unless, extra ), ], }

=end table

Using two C<!> symbols below generically to represent any pair of operators
that have the same precedence, the associativities specified above
for binary operators are interpreted as follows:

=begin table

    A  | Assoc   | Meaning of $a ! $b ! $c
    ===+=========+========================
    L  | left    |  ($a ! $b) ! $c
    R  | right   |  $a ! ($b ! $c)
    N  | non     |  ILLEGAL
    C  | chain   |  ($a ! $b) and ($b ! $c)
    X  | list    |  infix:<!>($a; $b; $c)

=end table

For unary operators this is interpreted as:

=begin table

    A  | Assoc   |  Meaning of !$a!
    ===+=========+==========================
    L  | left    |  (!$a)!
    R  | right   |  !($a!)
    N  | non     |  ILLEGAL

=end table

In the operator descriptions below, a default associativity of I<left>
is assumed.

=head1 Operator classification

X<|prefix operator>
X<|infix operator>
X<|postfix operator>
X<|circumfix operator>
X<|postcircumfix operator>
X<|method operators>

Operators can occur in several positions relative to a term:

=begin table

    \+term          | prefix
    term1 \+ term2  | infix
    term\+\+        | postfix
    (term)          | circumfix
    term1[term2]    | postcircumfix
    .+(term)        | method
=end table

Each operator (except method operators) is also available as a subroutine. The
name of the routine is formed from the operator category, followed by a colon,
then a list quote construct with the symbol(s) that make up the operator:

    infix:<+>(1, 2);                # same as 1 + 2
    circumfix:«[ ]»(<a b c>);       # same as [<a b c>]

As a special case, a I<listop> (list operator) can stand either as a
term or as a prefix. Subroutine calls are the most common listops. Other
cases include meta-reduced infix operators (C<[+] 1, 2, 3>) and the
L<#prefix ...> etc. stub operators.


Defining custom operators is covered in
L<Defining operators functions|/language/functions#Defining_operators>.

=head1 Metaoperators

Metaoperators can be parameterized with other operators or subroutines
in the same way as functions can take functions as parameters. To use a
subroutine as a parameter, prefix its name with a C<&>. Perl 6 will
generate the actual combined operator in the background, allowing the
mechanism to be applied to user defined operators. To disambiguate
chained metaoperators, enclose the inner operator in square brackets.
There are quite a few metaoperators with different semantics as
explained, next.

=head1 Substitution operators

Each substitution operator comes into two main forms: a lowercase one (e.g.,
C<s///>) that performs I<in-place> (i.e., I<destructive> behavior; and an
uppercase form (e.g., C<S///>) that provides a I<non-destructive> behavior.

=head2 X«C<s///> in-place substitution»

    my $str = 'old string';
    $str ~~ s/o .+ d/new/;
    say $str; # OUTPUT: «new string␤»

C<s///> operates on the C<$_> topical variable, changing it in
place. It uses the given
L«C<Regex>|/type/Regex» to find portions to replace and changes them to the
provided replacement string. Sets C<$/> to the L«C<Match>|/type/Match» object
or, if multiple matches were made, a L«C<List>|/type/List» of C<Match> objects.
Returns C<$/>.

It's common to use this operator with the C<~~> smartmatch operator, as it
aliases left-hand side to C<$_>, which C<s///> uses.

Regex captures can be referenced in the replacement part; it takes the same
adverbs as the L«C<.subst> method|/routine/subst», which go between the C<s>
and the opening C</>, separated with optional whitespace:

    my $str = 'foo muCKed into the lEn';

    # replace second 'o' with 'x'
    $str ~~ s:2nd/o/x/;

    # replace 'M' or 'L' followed by non-whitespace stuff with 'd'
    # and lower-cased version of that stuff:
    $str ~~ s :g :i/<[ML]> (\S+)/d{lc $0}/;

    say $str; # OUTPUT: «fox ducked into the den␤»

You can also use a different delimiter:

    my $str = 'foober';
    $str ~~ s!foo!fox!;
    $str ~~ s{b(.)r} = " d$0n";
    say $str; # OUTPUT: «fox den␤»

Non-paired characters can simply replace the original slashes. Paired
characters, like curly braces, are used only on the match portion, with the
substitution given by assignment (of anything: a string, a routine call, etc.).

=head2 X«C<S///> non-destructive substitution»

    say S/o .+ d/new/ with 'old string';      # OUTPUT: «new string␤»
    S:g/« (.)/$0.uc()/.say for <foo bar ber>; # OUTPUT: «Foo␤Bar␤Ber␤»

C<S///> uses the same semantics as the C<s///> operator, except
it leaves the original string intact
and I<returns the resultant string> instead of C<$/> (C<$/> still being set
to the same values as with C<s///>).

B<Note:> since the result is obtained as a return value, using this
operator with the C<~~> smartmatch operator is a mistake and will issue a
warning. To execute the substitution on a variable that isn't the C<$_> this
operator uses, alias it to C<$_> with C<given>, C<with>, or any other way.
Alternatively, use the L«C<.subst> method|/routine/subst».

=head2 X«C<tr///> in-place transliteration»

    my $str = 'old string';
    $str ~~ tr/dol/wne/;
    say $str; # OUTPUT: «new string␤»

C<tr///> operates on the C<$_> topical variable and changes it in place.
It behaves similar to
L«C<Str.trans>|/routine/trans» called with a single L<Pair|/type/Pair> argument, where
key is the matching part (characters C<dol> in the example above) and value is
the replacement part (characters C<wne> in the example above). Accepts the
same adverbs as L«C<Str.trans>|/routine/trans». Returns the L<StrDistance|/type/StrDistance> object
that measures the distance between original value and the resultant string.

    my $str = 'old string';
    $str ~~ tr:c:d/dol st//;
    say $str; # OUTPUT: «ring␤»

=head2 X«C<TR///> non-destructive transliteration»

    with 'old string' {
        say TR/dol/wne/; # OUTPUT: «new string␤»
    }

C<TR///> behaves the same as the C<tr///> operator,
except that it leaves the C<$_>
value untouched and instead returns the resultant string.

    say TR:d/dol // with 'old string'; # OUTPUT: «string␤»

=head1 Assignment operators

Infix operators can be combined with the assignment operator to modify a
value and apply the result to a container in one go. Containers will be
autovivified if possible. Some examples:

    my $a = 32;
    $a += 10;     # 42
    $a -= 2;      # 40

    $a = 3;
    $a min= 5;    # still 3
    $a min= 2;    # 2

    my $s = 'a';
    $s ~= 'b';    # 'ab'

This behavior is automatically extended to include custom-defined infix operators.

    sub infix:<space-concat> ($a, $b) { $a ~ " " ~ $b };
    my $a = 'word1';
    $a space-concat= 'word2';     # RESULT: «'word1 word2'»

Although not strictly operators, methods can be used in the same fashion.

    my Real $a = 1/2;
    $a = 3.14;
    $a .= round;      # RESULT: «3»

=head1 Negated relational operators
X<|! (negation metaoperator)>X<|!==>X<|!eq>

The result of a relational operator returning C<Bool> can be negated by
prefixing with C<!>. To avoid visual confusion with the C<!!> operator,
you may not modify any operator already beginning with C<!>.

There are shortcuts for C<!==> and C<!eq>, namely C<!=> and C<ne>.

    my $a = True;
    say so $a != True;    # OUTPUT: «False␤»
    my $i = 10;

    my $release = Date.new(:2015year, :12month, :24day);
    my $today = Date.today;
    say so $release !before $today;     # OUTPUT: «False␤»

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
