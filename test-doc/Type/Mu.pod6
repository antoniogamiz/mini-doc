=begin pod

=TITLE class Mu

=SUBTITLE The root of the Perl 6 type hierarchy.

    class Mu { }

The root of the Perl 6 type hierarchy. For the origin of the name, see
L<https://en.wikipedia.org/wiki/Mu_%28negative%29>. One can also say that
there are many undefined values in Perl 6, and C<Mu> is the I<most undefined>
value.

Note that most classes do not derive from C<Mu> directly, but rather from
L<Any|/type/Any>.

=head1 Methods


=head2 method iterator

Defined as:

    method iterator(--> Iterator)

Coerces the invocant to a C<list> by applying its L«C<.list>|/routine/list»
method and uses L«C<iterator>|/type/Iterable#method_iterator» on it.

    my $it = Mu.iterator;
    say $it.pull-one; # OUTPUT: «(Mu)␤»
    say $it.pull-one; # OUTPUT: «IterationEnd␤»

=head2 method defined X<|method,defined>

Declared as

    multi method defined(   --> Bool:D)

Returns C<False> on a type object, and C<True> otherwise.

    say Int.defined;                # OUTPUT: «False␤»
    say 42.defined;                 # OUTPUT: «True␤»

A few types (like L<Failure|/type/Failure>) override C<defined> to return
C<False> even for instances:

    sub fails() { fail 'oh noe' };
    say fails().defined;            # OUTPUT: «False␤»


=head2 routine defined

Declared as

    multi sub defined(Mu --> Bool:D)

invokes the C<.defined> method on the object and returns its result.


=head2 routine isa

    multi method isa(Mu $type     --> Bool:D)
    multi method isa(Str:D $type  --> Bool:D)

Returns C<True> if the invocant is an instance of class C<$type>, a subset type
or a derived class (through inheritance) of C<$type>.
L<C<does>|/routine/does#(Mu)_routine_does> is similar, but includes roles.

    my $i = 17;
    say $i.isa("Int");   # OUTPUT: «True␤»
    say $i.isa(Any);     # OUTPUT: «True␤»
    role Truish {};
    my $but-true = 0 but Truish;
    say $but-true.^name;        # OUTPUT: «Int+{Truish}␤»
    say $but-true.does(Truish); # OUTPUT: «True␤»
    say $but-true.isa(Truish);  # OUTPUT: «False␤»


=head2 routine does

    method does(Mu $type --> Bool:D)

Returns C<True> if and only if the invocant conforms to type C<$type>.

=for code
my $d = Date.new('2016-06-03');
say $d.does(Dateish);             # True    (Date does role Dateish)
say $d.does(Any);                 # True    (Date is a subclass of Any)
say $d.does(DateTime);            # False   (Date is not a subclass of DateTime)

Unlike L<C<isa>|/routine/isa#(Mu)_routine_isa>, which
returns C<True> only for superclasses, C<does> includes both superclasses and
roles.

=for code :preamble<my $d = Date.new('2016-06-03');>
say $d.isa(Dateish); # OUTPUT: «False␤»

Using the smartmatch operator L<~~|/routine/~~> is a more idiomatic alternative.

    my $d = Date.new('2016-06-03');
    say $d ~~ Dateish;                # OUTPUT: «True␤»
    say $d ~~ Any;                    # OUTPUT: «True␤»
    say $d ~~ DateTime;               # OUTPUT: «False␤»

=head2 routine Bool

    multi sub    Bool(Mu --> Bool:D)
    multi method Bool(   --> Bool:D)

Returns C<False> on the type object, and C<True> otherwise.

Many built-in types override this to be C<False> for empty collections, the
empty L<string|/type/Str> or numerical zeros

    say Mu.Bool;                    # OUTPUT: «False␤»
    say Mu.new.Bool;                # OUTPUT: «True␤»
    say [1, 2, 3].Bool;             # OUTPUT: «True␤»
    say [].Bool;                    # OUTPUT: «False␤»
    say %( hash => 'full' ).Bool;   # OUTPUT: «True␤»
    say {}.Bool;                    # OUTPUT: «False␤»
    say "".Bool;                    # OUTPUT: «False␤»
    say 0.Bool;                     # OUTPUT: «False␤»
    say 1.Bool;                     # OUTPUT: «True␤»
    say "0".Bool;                   # OUTPUT: «True␤»

=head2 method Capture

Declared as:

    method Capture(Mu:D: --> Capture:D)

Returns a L<Capture|/type/Capture> with named arguments corresponding to
invocant's public attributes:

    class Foo {
        has $.foo = 42;
        has $.bar = 70;
        method bar { 'something else' }
    }.new.Capture.say; # OUTPUT: «\(:bar("something else"), :foo(42))␤»

=head2 method Str

    multi method Str(--> Str)

Returns a string representation of the invocant, intended to be machine
readable. Method C<Str> warns on type objects, and produces the empty string.

    say Mu.Str;   # Use of uninitialized value of type Mu in string context.
    my @foo = [2,3,1];
    say @foo.Str  # OUTPUT: «2 3 1␤»

=head2 routine gist

    multi sub    gist(+args --> Str)
    multi method gist(   --> Str)

Returns a string representation of the invocant, optimized for fast recognition
by humans. As such lists will be truncated at 100 elements. Use C<.perl> to get
all elements.

The default C<gist> method in C<Mu> re-dispatches to the L<perl|/routine/perl>
method for defined invocants, and returns the type name in parenthesis for type
object invocants. Many built-in classes override the case of instances to
something more specific that may truncate output.

C<gist> is the method that L<say|/routine/say> calls implicitly, so C<say
$something> and C<say $something.gist> generally produce the same output.

    say Mu.gist;        # OUTPUT: «(Mu)␤»
    say Mu.new.gist;    # OUTPUT: «Mu.new␤»

=head2 routine perl

    multi method perl(--> Str)

Returns a Perlish representation of the object (i.e., can usually be
re-evaluated with L<EVAL|/routine/EVAL> to regenerate the object). The exact
output of C<perl> is implementation specific, since there are generally many
ways to write a Perl expression that produces a particular value.

=head2 method item

    method item(Mu \item:) is raw

Forces the invocant to be evaluated in item context and returns the value of it.

    say [1,2,3].item.perl;          # OUTPUT: «$[1, 2, 3]␤»
    say %( apple => 10 ).item.perl; # OUTPUT: «${:apple(10)}␤»
    say "abc".item.perl;            # OUTPUT: «"abc"␤»

=head2 method self

    method self(--> Mu)

Returns the object it is called on.

=head2 method clone

    multi method clone(Mu:U: *%twiddles)
    multi method clone(Mu:D: *%twiddles)

This method will clone type objects, or die if it's invoked with any argument.

=for code :skip-test<illustrates failure>
say Num.clone( :yes )
# OUTPUT: «(exit code 1) Cannot set attribute values when cloning a type object␤  in block <unit>␤␤»

If invoked with value objects, it creates a shallow clone of the invocant,
including shallow cloning of private attributes. Alternative values for
I<public> attributes can be provided via named arguments with names matching the
attributes' names.

=begin code
class Point2D {
    has ($.x, $.y);
    multi method gist(Point2D:D:) {
        "Point($.x, $.y)";
    }
}

my $p = Point2D.new(x => 2, y => 3);

say $p;                     # OUTPUT: «Point(2, 3)␤»
say $p.clone(y => -5);      # OUTPUT: «Point(2, -5)␤»
=end code

Note that C<.clone> does not go the extra mile to shallow-copy C<@.> and C<%.>
sigiled attributes and, if modified, the modifications will still be available
in the original object:

=begin code
class Foo {
    has $.foo is rw = 42;
    has &.boo is rw = { say "Hi" };
    has @.bar       = <a b>;
    has %.baz       = <a b c d>;
}

my $o1 = Foo.new;
with my $o2 = $o1.clone {
    .foo = 70;
    .bar = <Z Y>;
    .baz = <Z Y X W>;
    .boo = { say "Bye" };
}

# Hash and Array attribute modifications in clone appear in original as well:
say $o1;
# OUTPUT: «Foo.new(foo => 42, bar => ["Z", "Y"], baz => {:X("W"), :Z("Y")}, …␤»
say $o2;
# OUTPUT: «Foo.new(foo => 70, bar => ["Z", "Y"], baz => {:X("W"), :Z("Y")}, …␤»
$o1.boo.(); # OUTPUT: «Hi␤»
$o2.boo.(); # OUTPUT: «Bye␤»
=end code

To clone those, you could implement your own C<.clone> that clones the
appropriate attributes and passes the new values to C<Mu.clone>, for example,
via L«C<nextwith>|/language/functions#sub_nextwith».

=begin code
class Bar {
    has $.quux;
    has @.foo = <a b>;
    has %.bar = <a b c d>;
    method clone { nextwith :foo(@!foo.clone), :bar(%!bar.clone), |%_  }
}

my $o1 = Bar.new( :42quux );
with my $o2 = $o1.clone {
    .foo = <Z Y>;
    .bar = <Z Y X W>;
}

# Hash and Array attribute modifications in clone do not affect original:
say $o1;
# OUTPUT: «Bar.new(quux => 42, foo => ["a", "b"], bar => {:a("b"), :c("d")})␤»
say $o2;
# OUTPUT: «Bar.new(quux => 42, foo => ["Z", "Y"], bar => {:X("W"), :Z("Y")})␤»
=end code

The C<|%_> is needed to slurp the rest of the attributes that would have been
copied via shallow copy.

=head2 method new

    multi method new(*%attrinit)
    multi method new($, *@)

Default method for constructing (create + initialize) new objects
of a class. This method expects only named arguments which are then
used to initialize attributes with accessors of the same name.

Classes may provide their own C<new> method to override this default.

C<new> triggers an object construction mechanism that calls submethods named
C<BUILD> in each class of an inheritance hierarchy, if they exist. See
L<the documentation on object construction|/language/objects#Object_Construction>
for more information.

=end pod

# vim: expandtab softtabstop=4 shiftwidth=4 ft=perl6
